function [poss,frmap,xmap,ymap,spdmap,xchange] = ratemap(posx,posy,spkx,spky,binsize_override, pixel_ratio,min_dwell_dist, min_dwell_time, dt_pos, smooth, isShift)
% in this version, the place fields are generated by gaussian smoothed firing rate in each bin.
% the rate map implementation is based on Leutgeb et. al. Science, 2007, 315, 961-966
min_dwell = round(min_dwell_time / dt_pos);

% Generate empty position matrix
% WARNING: this assumes nice position data
% (i.e. no stray samples at edges)

smooth = smooth /100 * pixel_ratio;
xbinsize = binsize_override /100 * pixel_ratio;
ybinsize = xbinsize;
min_dwell_dist = min_dwell_dist / 100 * pixel_ratio;

if(isShift);
  minposx = min(posx);
  minposy = min(posy);

  posx = posx - minposx + 0.0001; % set lowerleftmostpoint to 0,0
  posy = posy - minposy + 0.0001; % 0.0001 is to avoid bin 0 in 1st point
  spkx = spkx - minposx + 0.0001;
  spky = spky - minposy + 0.0001;
end

dx = max(posx);
dy = max(posy);
xbins = ceil(max(dx)/xbinsize);
ybins = ceil(max(dy)/ybinsize);

xchange = max(posx)/xbins;														% this number can be used to multiply map coordinates and find corresponding position coordinates
% initialize x,y,hd,spd matrices

for x = 1:xbins
  for y = 1:ybins

   xmap{x,y} = [];
   ymap{x,y} = [];
   spdmap{x,y} = [];

  end
end

poss = zeros(xbins,ybins);

% compute firing rate
frmap = zeros(xbins,ybins);
for x = 1:xbins

  for y = 1:ybins

    %if (~isnan(poss(x,y)))

    if (isempty(spkx))
      frmap(x,y) = 0;     
      continue;
    end

    px = x*xbinsize-(xbinsize/2);
    py = y*ybinsize-(ybinsize/2);

    % compute spike distances
    %disp('Computing spike distances from current point');

    spk_ds = sqrt((px-spkx).^2+(py-spky).^2);
    %disp('Computing occupancy distances from current point');
    % compute occupancy distances
    occ_ds = sqrt((px-posx).^2+(py-posy).^2);
    
    bin_occ = length(find(occ_ds<min_dwell_dist));
    
    % do minimum dwelling filtering based on the distance from the centre of the bin
    if (bin_occ>= min_dwell)   
      poss(x,y) = bin_occ;
      frmap(x,y) = sum(gaussian_kernel(spk_ds/smooth)) / (sum(gaussian_kernel(occ_ds/smooth)) * (dt_pos/1000));
      % the spike occurrance is descrete data whereas the time is a continuous data and thus has to be
      % correted with sampling rate of a continuous data.
    else
      frmap(x,y) = NaN;
      poss(x,y) = NaN;
    end
  end

end
frmap = fliplr(frmap); frmap = rot90(frmap);
poss = fliplr(poss); poss = rot90(poss);